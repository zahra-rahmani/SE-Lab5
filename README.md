# Notes project

## Requirements
- Python3
- Postgres

## How to run

### Setup virtual environment

#### Create venv
```
python -m venv ./venv
```

#### Install requirements
```
python -m pip install -r requirements.txt
```

#### Activate venv
```
source ./venv/bin/activate
```

### Setup database
1. Create an instance of postgres database
2. Make migrations
    ```
    python manage.py makemigrations
    ```
3. Migrate
    ```
    python manage.py migrate
    ```

### Create an admin
```
python manage.py createsuperuser
```

## Important end-points
```
users/login/ --> login a user
users/me/ --> get information of logged-in user
users/create/ --> create a user
users/<id>/delete/ --> delete a user
notes/ --> list all notes of current user
notes/<id>/ --> get details of a note
notes/create/ --> create a note
notes/<id>/delete/ --> delete a note
```


#Report

## استقرار پروژه:
در این بخش ما دو فایل Dockerfile و docker-compose.yml در پروژه گذاشتیم که در ادامه به توضیح آنها می پردازیم:
Dockerfile:
![Screenshot 2024-08-14 010729](https://github.com/user-attachments/assets/a800a601-763c-4b17-878d-147a4dd281ac)


این فایل شامل دستوراتی است که برای ساخت یک تصویر داکر (Docker image) استفاده می‌شود. هر بخش این فایل عملکرد مشخصی دارد که به شرح زیر است:
 FROM docker.yektanet.tech/python:3.11:
 این دستور پایه‌ی تصویر داکر ما را مشخص می‌کند. در اینجا، ما از یک تصویر پایه Python 3.11 که در یک رجیستری خصوصی (docker.yektanet.tech) قرار دارد، استفاده میکنیم. این تصویر شامل نصب پیش‌فرض پایتون نسخه 3.11 است و از آن به عنوان پایه‌ای برای ساختن محیط اجرای کد استفاده می‌شود.
  WORKDIR /app:
  این دستور دایرکتوری کاری داخل کانتینر را مشخص می‌کند. یعنی هر دستور بعد از این، در این مسیر (دایرکتوری /app) اجرا خواهد شد. این دایرکتوری به عنوان مسیر پیش‌فرض برای عملیات کپی، نصب پکیج‌ها، و اجرای اسکریپت‌ها در داخل کانتینر استفاده می‌شود.
  COPY requirements.txt .:
  این دستور فایل requirements.txt را از سیستم میزبان (جایی که داکر فایل قرار دارد) به داخل کانتینر کپی می‌کند. فایل requirements.txt حاوی لیستی از کتابخانه‌ها و وابستگی‌های پایتونی است که برنامه نیاز دارد.
  RUN pip install -r requirements.txt:
  این دستور از ابزار pip برای نصب تمام وابستگی‌های مشخص شده در فایل requirements.txt استفاده می‌کند. این دستور مطمئن می‌شود که تمامی کتابخانه‌های پایتونی مورد نیاز در محیط داکر نصب شده و آماده استفاده هستند.
  COPY . .:
  این دستور تمام فایل‌ها و دایرکتوری‌های موجود در مسیر جاری روی سیستم میزبان (یعنی همان جایی که داکر فایل قرار دارد) را به مسیر کاری داخل کانتینر (/app) کپی می‌کند. این عملیات تمامی کدهای پروژه، فایل‌ها، و سایر منابع را به کانتینر منتقل می‌کند تا در آنجا استفاده شوند.
به طور خلاصه، این فایل داکر یک محیط پایتون 3.11 ایجاد می‌کند، وابستگی‌های پروژه را نصب کرده و سپس تمام فایل‌های پروژه را به داخل کانتینر کپی می‌کند تا بتوانید برنامه‌تان را داخل داکر اجرا کنید.






Docker-compose.yml:

![Screenshot 2024-08-14 010852](https://github.com/user-attachments/assets/318263fe-e104-4fd6-a804-c020e5f24c2e)
1

این فایل شامل تعریف سرویس‌ها و کانتینرهایی است که برای اجرای یک برنامه نیاز داریم. هر بخش این فایل به توضیح زیر است:
services:
این بخش اصلی فایل داکر کمپوز است که سرویس‌های مختلف را تعریف می‌کند. در اینجا دو سرویس به نام‌های db و app تعریف شده‌اند.
  db:
  image: docker.yektanet.tech/postgres:
  این دستور مشخص می‌کند که سرویس db از یک تصویر داکر پستگرس (Postgres) استفاده می‌کند که در رجیستری خصوصی (docker.yektanet.tech) قرار دارد.
  environment:
  این بخش شامل متغیرهای محیطی است که برای تنظیم دیتابیس استفاده می‌شود:
  POSTGRES_DB=postgres: این متغیر نام دیتابیسی را که قرار است ایجاد شود، مشخص می‌کند (در اینجا نام دیتابیس postgres است).
  POSTGRES_USER=postgres: این متغیر نام کاربری برای دیتابیس را مشخص می‌کند (در اینجا postgres).
  POSTGRES_PASSWORD=postgres: این متغیر رمز عبور برای کاربر دیتابیس را مشخص می‌کند (در اینجا postgres).
  app:
  build: .:
  این دستور مشخص می‌کند که سرویس app باید از داکرفایلی که در مسیر جاری قرار دارد (یعنی همان پوشه‌ای که فایل داکر کمپوز قرار گرفته) برای ساخت تصویر داکر استفاده کند.
  command: python manage.py runserver 0.0.0.0:8000:
  این دستور مشخص می‌کند که زمانی که کانتینر مربوط به سرویس app اجرا شد، این فرمان اجرا شود. این فرمان در واقع سرور توسعه (Development Server) برنامه جنگو (Django) را راه‌اندازی می‌کند و آن را در پورت 8000 روی همه‌ی آدرس‌های IP موجود (0.0.0.0:8000) گوش به زنگ می‌کند.
  ports:
  این بخش مشخص می‌کند که کدام پورت از کانتینر باید به کدام پورت از میزبان نگاشت شود:
  "8000:8000": این دستور پورت 8000 کانتینر را به پورت 8000 روی میزبان (سیستم لوکال) نگاشت می‌کند، به طوری که سرور برنامه از طریق localhost:8000 قابل دسترس خواهد بود.
  environment:
  این بخش شامل متغیرهای محیطی است که برای پیکربندی ارتباط برنامه با دیتابیس استفاده می‌شود:
  POSTGRES_NAME=postgres: نام دیتابیس که برنامه به آن متصل می‌شود (در اینجا postgres).
  POSTGRES_USER=postgres: نام کاربری برای اتصال به دیتابیس (در اینجا postgres).
  POSTGRES_PASSWORD=postgres: رمز عبور برای اتصال به دیتابیس (در اینجا postgres).
  depends_on:
  این بخش نشان می‌دهد که سرویس app به سرویس دیگری وابسته است، یعنی سرویس app باید منتظر بماند تا سرویس db (دیتابیس) راه‌اندازی و آماده به کار شود.
خلاصه:
این فایل داکر کمپوز دو سرویس اصلی را تعریف می‌کند:
  db: سرویس دیتابیس Postgres.
  app: برنامه جنگو (Django) که به دیتابیس متصل می‌شود و سرور را راه‌اندازی می‌کند.
این فایل به شما امکان می‌دهد که تمام زیرساخت‌های مورد نیاز برای اجرای برنامه‌تان را با یک دستور ساده (docker-compose up) راه‌اندازی کنید.



=================================================================


تعامل با داکر:
بعد از اجرای فایل داکر با docker compose up کانتینر هایی بر روی داکر سیستم ساخته میشود و همچنین با دستور docker images  میتوانیم همه تصاویر ایجاد شده و با دستور docker ps تمام کانتنینرهای فعال را ببینیم و با  docker ps -a همه کانتینرهای فعال و غیرفعال را میتوان دید:


Docker images:

![Screenshot 2024-08-14 011004](https://github.com/user-attachments/assets/316febdf-fc91-4963-be63-2c9a0273ff05)


 که در آنها تصویر اول و سوم مربوط به پروژه ما میباشد.
 
Docker ps:


![Screenshot 2024-08-14 011025](https://github.com/user-attachments/assets/5f10d1ae-9c78-452f-8b48-085c32ece37a)

 
 Docker ps -a:
 

 ![Screenshot 2024-08-14 011102](https://github.com/user-attachments/assets/666a062d-0539-4894-abef-fcc0c299b36c)
 


حال با دستور docker compose exec app bash وارد کانتینر برنامه مان میشویم و دستور python manage.py migrate را میزنیم تا موارد مربوط به مدل ها را در دیتابیسی که با داکر بالا آوردیم مایگریت کند و همانطور که در نتیجه میبینیم همه چیز به درستی اجرا میشود:


![Screenshot 2024-08-14 011233](https://github.com/user-attachments/assets/2d5d4949-32b9-448e-a0c6-335bf63a3e61)



## ارسال درخواست ها

![Screenshot 2024-08-14 011342](https://github.com/user-attachments/assets/f7d7528e-cd0b-44f2-b0a3-57cc8ffefa84)

![Screenshot 2024-08-14 011354](https://github.com/user-attachments/assets/5ec52f38-f76c-4872-8cf5-5b320a9d6fc7)

![Screenshot 2024-08-14 011415](https://github.com/user-attachments/assets/6ebf034d-5e6e-408f-a797-c776a18041bc)

![Screenshot 2024-08-14 011435](https://github.com/user-attachments/assets/2609313b-8c03-46cd-944d-444ea818291d)

![Screenshot 2024-08-14 011455](https://github.com/user-attachments/assets/dee4d03f-8a45-4a28-adbc-07743196a141)

![Screenshot 2024-08-14 011510](https://github.com/user-attachments/assets/2e976b72-2366-45c5-9825-495b2f2af569)

![Screenshot 2024-08-14 011536](https://github.com/user-attachments/assets/0cf02cb5-f48f-428a-b717-d9d4923026fa)

![Screenshot 2024-08-14 011548](https://github.com/user-attachments/assets/08e43191-6377-4775-8b08-71dd9b3b323d)



# پرسش ها

### وظایف Dockerfile، image و container را توضیح دهید.

Dockerfile:

یک فایل متنی ساده است که حاوی دستورات و تنظیماتی است که به Docker می‌گوید چگونه یک Image بسازد. این فایل معمولاً شامل دستورات نصب نرم‌افزارها، کپی کردن فایل‌ها به داخل ایمیج، تنظیم متغیرهای محیطی، و تنظیمات مربوط به اجرای برنامه است. به عبارت دیگر، Dockerfile دستورالعمل‌های ساخت یک Image را تعریف می‌کند.

Docker Image:

 یک بسته قابل حمل و سبک است که شامل تمام آن چیزی است که برنامه برای اجرا نیاز دارد: از جمله کد برنامه، محیط اجرایی، کتابخانه‌ها و وابستگی‌ها. ایمیج‌ها بر اساس دستورات موجود در Dockerfile ساخته می‌شوند. وقتی Dockerfile را اجرا می‌کنید، Docker یک Image می‌سازد. ایمیج ها ها فقط خواندنی هستند و نمی‌توان مستقیماً در آن‌ها تغییراتی ایجاد کرد. اگر بخواهید تغییری ایجاد کنید، باید یک Dockerfile جدید بنویسید و Image جدیدی بسازید.


 Docker Container:

 یک نمونه در حال اجرای یک Image است. کانتینرها محیط‌های جداگانه‌ای هستند که به Image اجازه می‌دهند تا به صورت مستقل اجرا شود. به عبارت دیگر، کانتینرها از یک Image ساخته می‌شوند و سپس در سیستم میزبان اجرا می‌شوند. هر کانتینر می‌تواند شامل یک برنامه کاربردی یا یک سرویس کوچک باشد.

بر خلاف Image که ثابت است، Container می‌تواند تغییر کند. برای مثال، شما می‌توانید فایل‌هایی را در داخل یک کانتینر ویرایش کنید. با این حال، تغییرات درون کانتینر پس از اتمام عمر کانتینر از بین می‌رود، مگر اینکه تغییرات را در یک Image جدید ذخیره کنید.




### از kubernetes برای انجام چه کارهایی می‌توان استفاده کرد؟ رابطه آن با داکر چیست؟


یک سیستم مدیریت کانتینر است که توسط گوگل توسعه داده شده و اکنون به عنوان یک پروژه منبع باز توسط جامعه جهانی پشتیبانی می‌شود. از Kubernetes برای انجام موارد زیر می‌توان استفاده کرد:

استقرار (Deployment) برنامه‌ها: Kubernetes به شما اجازه می‌دهد تا برنامه‌های خود را به صورت خودکار بر روی یک مجموعه از سرورها مستقر کنید.

مدیریت بارکاری (Workloads): Kubernetes می‌تواند بارهای کاری را در کانتینرها توزیع کرده و منابع سیستم را به طور هوشمند مدیریت کند.

مقیاس‌پذیری خودکار (Auto-scaling): با استفاده از Kubernetes می‌توانید تعداد کانتینرهای در حال اجرا را بر اساس تقاضای بارکاری افزایش یا کاهش دهید.

متوازن‌سازی بار (Load Balancing): Kubernetes می‌تواند ترافیک ورودی را بین چندین کانتینر به طور متوازن توزیع کند.

بازیابی خودکار (Self-healing): Kubernetes می‌تواند کانتینرهای خراب را به طور خودکار جایگزین کند و از سرویس‌های شما محافظت کند.

مدیریت پیکربندی (Configuration Management): Kubernetes مدیریت تنظیمات و پیکربندی‌ها را برای کانتینرها آسان‌تر می‌کند.

به‌روزرسانی بدون توقف (Rolling Updates): می‌توانید بدون ایجاد وقفه در سرویس‌ها، به‌روزرسانی‌ها را انجام دهید.



### رابطه Kubernetes و Docker


هر دو Docker و Kubernetes هر دو در زمینه مدیریت کانتینرها استفاده می‌شوند، اما در سطوح مختلفی کار می‌کنند:

داکر یک پلتفرم است که امکان ایجاد، استقرار و اجرای کانتینرها را فراهم می‌کند. Docker ابزارهایی برای مدیریت کانتینرها در یک ماشین واحد ارائه می‌دهد.

همچنین Kubernetes یک پلتفرم اورکستراسیون کانتینر است که بر روی چندین ماشین (یا خوشه‌های سرور) کار می‌کند. Kubernetes می‌تواند تعداد زیادی از کانتینرها را در یک محیط توزیع‌شده مدیریت کند.

در واقع، شما می‌توانید Docker را به عنوان ابزاری برای ایجاد و اجرای کانتینرها در نظر بگیرید، و Kubernetes را به عنوان سیستمی برای مدیریت و مقیاس‌دهی آن کانتینرها در یک محیط تولیدی بزرگ‌تر. Kubernetes با Docker به خوبی کار می‌کند و از آن به عنوان یک runtime کانتینر استفاده می‌کند، هرچند که با سایر runtimeها نیز سازگار است.










